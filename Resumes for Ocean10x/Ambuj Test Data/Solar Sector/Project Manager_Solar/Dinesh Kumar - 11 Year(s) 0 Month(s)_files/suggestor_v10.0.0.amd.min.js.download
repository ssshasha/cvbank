define(['exports'], function (exports) { 'use strict';

function getCookie(name) {
    var start = document.cookie.indexOf(name + "=");
    var len = start + name.length + 1;
    if (!start && name != document.cookie.substring(0, name.length)) {
        return "";
    }
    if (start == -1) return "";
    var end = document.cookie.indexOf(';', len);
    if (end == -1) end = document.cookie.length;
    return decodeURI(document.cookie.substring(len, end));
}

/*global module*/
/*
MIT LICENSE
Copyright (c) 2007 Monsur Hossain (http://monsur.hossai.in)

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

// Avoid polluting the global namespace if we're using a module loader
//(function(){

/**
 * Creates a new Cache object.
 * @param {number} maxSize The maximum size of the cache (or -1 for no max).
 * @param {boolean} debug Whether to log events to the console.log.
 * @constructor
 */
function Cache(maxSize, debug, storage) {
  this.maxSize_ = maxSize || -1;
  this.debug_ = debug || false;
  this.storage_ = storage || new Cache.BasicCacheStorage();

  this.fillFactor_ = 0.75;

  this.stats_ = {};
  this.stats_['hits'] = 0;
  this.stats_['misses'] = 0;
  this.log_('Initialized cache with size ' + maxSize);
}

/**
 * An easier way to refer to the priority of a cache item
 * @enum {number}
 */
Cache.Priority = {
  'LOW': 1,
  'NORMAL': 2,
  'HIGH': 4
};

/**
 * Basic in memory cache storage backend.
 * @constructor
 */
Cache.BasicCacheStorage = function () {
  this.items_ = {};
  this.count_ = 0;
};
Cache.BasicCacheStorage.prototype.get = function (key) {
  return this.items_[key];
};
Cache.BasicCacheStorage.prototype.set = function (key, value) {
  if (typeof this.get(key) === "undefined") this.count_++;
  this.items_[key] = value;
};
Cache.BasicCacheStorage.prototype.size = function (key, value) {
  return this.count_;
};
Cache.BasicCacheStorage.prototype.remove = function (key) {
  var item = this.get(key);
  if (typeof item !== "undefined") this.count_--;
  delete this.items_[key];
  return item;
};
Cache.BasicCacheStorage.prototype.keys = function () {
  var ret = [],
      p;
  for (p in this.items_) {
    ret.push(p);
  }return ret;
};

/**
 * Local Storage based persistant cache storage backend.
 * If a size of -1 is used, it will purge itself when localStorage
 * is filled. This is 5MB on Chrome/Safari.
 * WARNING: The amortized cost of this cache is very low, however,
 * when a the cache fills up all of localStorage, and a purge is required, it can
 * take a few seconds to fetch all the keys and values in storage.
 * Since localStorage doesn't have namespacing, this means that even if this
 * individual cache is small, it can take this time if there are lots of other
 * other keys in localStorage.
 *
 * @param {string} namespace A string to namespace the items in localStorage. Defaults to 'default'.
 * @constructor
 */
Cache.LocalStorageCacheStorage = function (namespace) {
  this.prefix_ = 'cache-storage.' + (namespace || 'default') + '.';
  // Regexp String Escaping from http://simonwillison.net/2006/Jan/20/escape/#p-6
  var escapedPrefix = this.prefix_.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  this.regexp_ = new RegExp('^' + escapedPrefix);
};
Cache.LocalStorageCacheStorage.prototype.get = function (key) {
  var item = window.localStorage[this.prefix_ + key];
  if (item) return JSON.parse(item);
  return null;
};
Cache.LocalStorageCacheStorage.prototype.set = function (key, value) {
  window.localStorage[this.prefix_ + key] = JSON.stringify(value);
};
Cache.LocalStorageCacheStorage.prototype.size = function (key, value) {
  return this.keys().length;
};
Cache.LocalStorageCacheStorage.prototype.remove = function (key) {
  var item = this.get(key);
  delete window.localStorage[this.prefix_ + key];
  return item;
};
Cache.LocalStorageCacheStorage.prototype.keys = function () {
  var ret = [],
      p;
  for (p in window.localStorage) {
    if (p.match(this.regexp_)) ret.push(p.replace(this.prefix_, ''));
  }
  return ret;
};

/**
 * Retrieves an item from the cache.
 * @param {string} key The key to retrieve.
 * @return {Object} The item, or null if it doesn't exist.
 */
Cache.prototype.getItem = function (key) {

  // retrieve the item from the cache
  var item = this.storage_.get(key);

  if (item != null) {
    if (!this.isExpired_(item)) {
      // if the item is not expired
      // update its last accessed date
      item.lastAccessed = new Date().getTime();
    } else {
      // if the item is expired, remove it from the cache
      this.removeItem(key);
      item = null;
    }
  }

  // return the item value (if it exists), or null
  var returnVal = item ? item.value : null;
  if (returnVal) {
    this.stats_['hits']++;
    this.log_('Cache HIT for key ' + key);
  } else {
    this.stats_['misses']++;
    this.log_('Cache MISS for key ' + key);
  }
  return returnVal;
};

Cache._CacheItem = function (k, v, o) {
  if (!k) {
    throw new Error("key cannot be null or empty");
  }
  this.key = k;
  this.value = v;
  o = o || {};
  if (o.expirationAbsolute) {
    o.expirationAbsolute = o.expirationAbsolute.getTime();
  }
  if (!o.priority) {
    o.priority = Cache.Priority.NORMAL;
  }
  this.options = o;
  this.lastAccessed = new Date().getTime();
};

/**
 * Sets an item in the cache.
 * @param {string} key The key to refer to the item.
 * @param {Object} value The item to cache.
 * @param {Object} options an optional object which controls various caching
 *    options:
 *      expirationAbsolute: the datetime when the item should expire
 *      expirationSliding: an integer representing the seconds since
 *                         the last cache access after which the item
 *                         should expire
 *      priority: How important it is to leave this item in the cache.
 *                You can use the values Cache.Priority.LOW, .NORMAL, or
 *                .HIGH, or you can just use an integer.  Note that
 *                placing a priority on an item does not guarantee
 *                it will remain in cache.  It can still be purged if
 *                an expiration is hit, or if the cache is full.
 *      callback: A function that gets called when the item is purged
 *                from cache.  The key and value of the removed item
 *                are passed as parameters to the callback function.
 */
Cache.prototype.setItem = function (key, value, options) {

  // add a new cache item to the cache
  if (this.storage_.get(key) != null) {
    this.removeItem(key);
  }
  this.addItem_(new Cache._CacheItem(key, value, options));
  this.log_("Setting key " + key);

  // if the cache is full, purge it
  if (this.maxSize_ > 0 && this.size() > this.maxSize_) {
    var that = this;
    setTimeout(function () {
      that.purge_.call(that);
    }, 0);
  }
};

/**
 * Removes all items from the cache.
 */
Cache.prototype.clear = function () {
  // loop through each item in the cache and remove it
  var keys = this.storage_.keys();
  for (var i = 0; i < keys.length; i++) {
    this.removeItem(keys[i]);
  }
  this.log_('Cache cleared');
};

/**
 * @return {Object} The hits and misses on the cache.
 */
Cache.prototype.getStats = function () {
  return this.stats_;
};

/**
 * @return {string} Returns an HTML string representation of the cache.
 */
Cache.prototype.toHtmlString = function () {
  var returnStr = this.size() + " item(s) in cache<br /><ul>";
  var keys = this.storage_.keys();
  for (var i = 0; i < keys.length; i++) {
    var item = this.storage_.get(keys[i]);
    returnStr = returnStr + "<li>" + item.key.toString() + " = " + item.value.toString() + "</li>";
  }
  returnStr = returnStr + "</ul>";
  return returnStr;
};

/**
 * Allows it to resize the Cache capacity if needed.
 * @param	{integer} newMaxSize the new max amount of stored entries within the Cache
 */
Cache.prototype.resize = function (newMaxSize) {
  this.log_('Resizing Cache from ' + this.maxSize_ + ' to ' + newMaxSize);
  // Set new size before purging so we know how many items to purge
  var oldMaxSize = this.maxSize_;
  this.maxSize_ = newMaxSize;

  if (newMaxSize > 0 && (oldMaxSize < 0 || newMaxSize < oldMaxSize)) {
    if (this.size() > newMaxSize) {
      // Cache needs to be purged as it does contain too much entries for the new size
      this.purge_();
    } // else if cache isn't filled up to the new limit nothing is to do
  }
  // else if newMaxSize >= maxSize nothing to do
  this.log_('Resizing done');
};

/**
 * Removes expired items from the cache.
 */
Cache.prototype.purge_ = function () {
  var tmparray = new Array();
  var purgeSize = Math.round(this.maxSize_ * this.fillFactor_);
  if (this.maxSize_ < 0) purgeSize = this.size() * this.fillFactor_;
  // loop through the cache, expire items that should be expired
  // otherwise, add the item to an array
  var keys = this.storage_.keys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var item = this.storage_.get(key);
    if (this.isExpired_(item)) {
      this.removeItem(key);
    } else {
      tmparray.push(item);
    }
  }

  if (tmparray.length > purgeSize) {
    // sort this array based on cache priority and the last accessed date
    tmparray = tmparray.sort(function (a, b) {
      if (a.options.priority != b.options.priority) {
        return b.options.priority - a.options.priority;
      } else {
        return b.lastAccessed - a.lastAccessed;
      }
    });
    // remove items from the end of the array
    while (tmparray.length > purgeSize) {
      var ritem = tmparray.pop();
      this.removeItem(ritem.key);
    }
  }
  this.log_('Purged cached');
};

/**
 * Add an item to the cache.
 * @param {Object} item The cache item to add.
 * @private
 */
Cache.prototype.addItem_ = function (item, attemptedAlready) {
  try {
    this.storage_.set(item.key, item);
  } catch (err) {
    if (attemptedAlready) {
      this.log_('Failed setting again, giving up: ' + err.toString());
      throw err;
    }
    this.log_('Error adding item, purging and trying again: ' + err.toString());
    this.purge_();
    this.addItem_(item, true);
  }
};

/**
 * Remove an item from the cache, call the callback function (if it exists).
 * @param {String} key The key of the item to remove
 */
Cache.prototype.removeItem = function (key) {
  var item = this.storage_.remove(key);
  this.log_("removed key " + key);

  // if there is a callback function, call it at the end of execution
  if (item && item.options && item.options.callback) {
    setTimeout(function () {
      item.options.callback.call(null, item.key, item.value);
    }, 0);
  }
  return item ? item.value : null;
};

/**
 * Scan through each item in the cache and remove that item if it passes the
 * supplied test.
 * @param {Function} test   A test to determine if the given item should be removed.
 *							The item will be removed if test(key, value) returns true.
 */
Cache.prototype.removeWhere = function (test) {
  // Get a copy of the keys array - it won't be modified when we remove items from storage
  var keys = this.storage_.keys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var item = this.storage_.get(key);
    if (test(key, item.value) === true) {
      this.removeItem(key);
    }
  }
};

Cache.prototype.size = function () {
  return this.storage_.size();
};

/**
 * @param {Object} item A cache item.
 * @return {boolean} True if the item is expired
 * @private
 */
Cache.prototype.isExpired_ = function (item) {
  var now = new Date().getTime();
  var expired = false;
  if (item.options.expirationAbsolute && item.options.expirationAbsolute < now) {
    // if the absolute expiration has passed, expire the item
    expired = true;
  }
  if (!expired && item.options.expirationSliding) {
    // if the sliding expiration has passed, expire the item
    var lastAccess = item.lastAccessed + item.options.expirationSliding * 1000;
    if (lastAccess < now) {
      expired = true;
    }
  }
  return expired;
};

/**
 * Logs a message to the console.log if debug is set to true.
 * @param {string} msg The message to log.
 * @private
 */
Cache.prototype.log_ = function (msg) {
  if (this.debug_) {
    console.log(msg);
  }
};

// Establish the root object, `window` in the browser, or `global` on the server.
var root = window;

if (typeof module !== "undefined" && module.exports) {
  module.exports = Cache;
} else if (typeof define == "function" && define.amd) {
  define("ncCache", function () {
    return Cache;
  });
} else {
  root.Cache = Cache;
}

/*!
 * Naukri.com Cache Library
 * http://www.naukri.com/
 *
 * Author: Rahul Batra (rahul.batra@naukri.com, rahul.batra@gmail.com)
 * Copyright 2014 Naukri.com
 */

// jQuery.extend({
//   stringify: function stringify(obj) {
//     var t = typeof (obj);
//     if (t != "object" || obj === null) {
//       if (t == "string") obj = '"' + obj + '"';
//       return String(obj);
//     } else {
//       var n, v, json = [], arr = (obj && obj.constructor == Array);
//       for (n in obj) {
//         v = obj[n];
//         t = typeof(v);
//         if (obj.hasOwnProperty(n)) {
//           if (t == "string") v = '"' + v + '"'; else if (t == "object" && v !== null) v = jQuery.stringify(v);
//           json.push((arr ? "" : '"' + n + '":') + String(v));
//         }
//       }
//       return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
//     }
//   }
// });

Cache.UserDataCacheStorage = function (namespace) {
  var namespace = namespace;
  var store = document.createElement('div');
  store.style.display = 'none';
  document.getElementsByTagName('head')[0].appendChild(store);
  store.addBehavior('#default#userdata');

  this.get = function (key) {
    store.load(namespace);
    var value = store.getAttribute(key);
    return value ? $.parseJSON(value) : null;
  };

  this.set = function (key, value) {
    store.load(namespace);
    store.setAttribute(key, $.stringify(value));
    store.save(namespace);
  };

  this.size = function (key, value) {
    return store.XMLDocument.documentElement.attributes.length;
  };

  this.remove = function (key) {
    store.load(namespace);
    store.removeAttribute(key);
    store.save(namespace);
  };

  this.keys = function () {
    store.load(namespace);
    var i = -1,
        keys = [],
        attr;
    while (attr = store.XMLDocument.documentElement.attributes[++i]) {
      keys.push(attr.name);
    }
    return keys;
  };
};
/*!
 * Naukri.com Cache Library
 * http://www.naukri.com/
 *
 * Author: Rahul Batra (rahul.batra@naukri.com, rahul.batra@gmail.com)
 * Copyright 2014 Naukri.com
 */
var ncCacheFactory = {
  getCache: function getCache(appId, storageType) {
    if (typeof appId == "undefined" || parseInt(appId) <= 0) {
      throw new 'Invalid app id: '() + appId;
    }
    storageType = storageType || 'localStorage';
    var isOldIE = window.navigator.userAgent.match(/MSIE 7/);
    var cacheStore = null;
    if (storageType == 'localStorage') {
      if (isOldIE) {
        cacheStore = new Cache.UserDataCacheStorage(String(appId));
      } else if (typeof window.localStorage != 'undefined') {
        cacheStore = new Cache.LocalStorageCacheStorage(String(appId));
      }
    }
    if (cacheStore == null) {
      throw 'Unsupported storage type: ' + storageType;
    }
    return new Cache(-1, false, cacheStore);
  }
};

// import $ from 'jquery';

/*
 * jQuery JSONP Core Plugin 2.4.0 (2012-08-21)
 *
 * https://github.com/jaubourg/jquery-jsonp
 *
 * Copyright (c) 2012 Julian Aubourg
 *
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 */

// ###################### UTILITIES ##

// Noop
function noop() {}

// Generic callback
function genericCallback(data) {
	lastValue = [data];
}

// Call if defined
function callIfDefined(method, object, parameters) {
	return method && method.apply(object.context || object, parameters);
}

// Give joining character given url
function qMarkOrAmp(url) {
	return (/\?/.test(url) ? "&" : "?"
	);
}

var STR_ASYNC = "async";
var STR_CHARSET = "charset";
var STR_EMPTY = "";
var STR_ERROR = "error";
var STR_INSERT_BEFORE = "insertBefore";
var STR_JQUERY_JSONP = "_jqjsp";
var STR_ON = "on";
var STR_ON_CLICK = STR_ON + "click";
var STR_ON_ERROR = STR_ON + STR_ERROR;
var STR_ON_LOAD = STR_ON + "load";
var STR_ON_READY_STATE_CHANGE = STR_ON + "readystatechange";
var STR_READY_STATE = "readyState";
var STR_REMOVE_CHILD = "removeChild";
var STR_SCRIPT_TAG = "<script>";
var STR_SUCCESS = "success";
var STR_TIMEOUT = "timeout";
var win = window;
var Deferred = $.Deferred;
var head = $("head")[0] || document.documentElement;
var pageCache = {};
var count = 0;
var lastValue;
var xOptionsDefaults = {
	//beforeSend: undefined,
	//cache: false,
	callback: STR_JQUERY_JSONP,
	//callbackParameter: undefined,
	//charset: undefined,
	//complete: undefined,
	//context: undefined,
	//data: "",
	//dataFilter: undefined,
	//error: undefined,
	//pageCache: false,
	//success: undefined,
	//timeout: 0,
	//traditional: false,
	url: location.href
};
var opera = win.opera;
var oldIE = !!$("<div>").html("<!--[if IE]><i><![endif]-->").find("i").length;

// ###################### MAIN FUNCTION ##
function jsonp(xOptions) {

	// Build data with default
	xOptions = $.extend({}, xOptionsDefaults, xOptions);

	// References to xOptions members (for better minification)
	var successCallback = xOptions.success,
	    errorCallback = xOptions.error,
	    completeCallback = xOptions.complete,
	    dataFilter = xOptions.dataFilter,
	    callbackParameter = xOptions.callbackParameter,
	    successCallbackName = xOptions.callback,
	    cacheFlag = xOptions.cache,
	    pageCacheFlag = xOptions.pageCache,
	    charset = xOptions.charset,
	    url = xOptions.url,
	    data = xOptions.data,
	    timeout = xOptions.timeout,
	    pageCached,


	// Abort/done flag
	done = 0,


	// Life-cycle functions
	cleanUp = noop,


	// Support vars
	supportOnload,
	    supportOnreadystatechange,


	// Request execution vars
	firstChild,
	    script,
	    scriptAfter,
	    timeoutTimer;

	// If we have Deferreds:
	// - substitute callbacks
	// - promote xOptions to a promise
	Deferred && Deferred(function (defer) {
		defer.done(successCallback).fail(errorCallback);
		successCallback = defer.resolve;
		errorCallback = defer.reject;
	}).promise(xOptions);

	// Create the abort method
	xOptions.abort = function () {
		!done++ && cleanUp();
	};

	// Call beforeSend if provided (early abort if false returned)
	if (callIfDefined(xOptions.beforeSend, xOptions, [xOptions]) === false || done) {
		// remove JsLInt Error by replace (!1 to flase)
		return xOptions;
	}

	// Control entries
	url = url || STR_EMPTY;
	data = data ? typeof data == "string" ? data : $.param(data, xOptions.traditional) : STR_EMPTY;

	// Build final url
	url += data ? qMarkOrAmp(url) + data : STR_EMPTY;

	// Add callback parameter if provided as option
	callbackParameter && (url += qMarkOrAmp(url) + encodeURIComponent(callbackParameter) + "=?");

	// Add anticache parameter if needed
	!cacheFlag && !pageCacheFlag && (url += qMarkOrAmp(url) + "_" + new Date().getTime() + "=");

	// Replace last ? by callback parameter
	url = url.replace(/=\?(&|$)/, "=" + successCallbackName + "$1");

	// Success notifier
	function notifySuccess(json) {

		if (!done++) {

			cleanUp();
			// Pagecache if needed
			pageCacheFlag && (pageCache[url] = { s: [json] });
			// Apply the data filter if provided
			dataFilter && (json = dataFilter.apply(xOptions, [json]));
			// Call success then complete
			callIfDefined(successCallback, xOptions, [json, STR_SUCCESS, xOptions]);
			callIfDefined(completeCallback, xOptions, [xOptions, STR_SUCCESS]);
		}
	}

	// Error notifier
	function notifyError(type) {

		if (!done++) {

			// Clean up
			cleanUp();
			// If pure error (not timeout), cache if needed
			pageCacheFlag && type != STR_TIMEOUT && (pageCache[url] = type);
			// Call error then complete
			callIfDefined(errorCallback, xOptions, [xOptions, type]);
			callIfDefined(completeCallback, xOptions, [xOptions, type]);
		}
	}

	// Check page cache
	if (pageCacheFlag && (pageCached = pageCache[url])) {

		pageCached.s ? notifySuccess(pageCached.s[0]) : notifyError(pageCached);
	} else {

		// Install the generic callback
		// (BEWARE: global namespace pollution ahoy)
		win[successCallbackName] = genericCallback;

		// Create the script tag
		script = $(STR_SCRIPT_TAG)[0];
		script.id = STR_JQUERY_JSONP + count++;

		// Set charset if provided
		if (charset) {
			script[STR_CHARSET] = charset;
		}

		opera && opera.version() < 11.60 ?
		// onerror is not supported: do not set as async and assume in-order execution.
		// Add a trailing script to emulate the event
		(scriptAfter = $(STR_SCRIPT_TAG)[0]).text = "document.getElementById('" + script.id + "')." + STR_ON_ERROR + "()" :
		// onerror is supported: set the script as async to avoid requests blocking each others
		script[STR_ASYNC] = STR_ASYNC;

		// Internet Explorer: event/htmlFor trick
		if (oldIE) {
			script.htmlFor = script.id;
			script.event = STR_ON_CLICK;
		}

		// Attached event handlers
		script[STR_ON_LOAD] = script[STR_ON_ERROR] = script[STR_ON_READY_STATE_CHANGE] = function (result) {

			// Test readyState if it exists
			if (!script[STR_READY_STATE] || !/i/.test(script[STR_READY_STATE])) {

				try {

					script[STR_ON_CLICK] && script[STR_ON_CLICK]();
				} catch (_) {}

				result = lastValue;
				lastValue = 0;
				result ? notifySuccess(result[0]) : notifyError(STR_ERROR);
			}
		};

		// Set source
		script.src = url;

		// Re-declare cleanUp function
		cleanUp = function cleanUp(i) {
			timeoutTimer && clearTimeout(timeoutTimer);
			script[STR_ON_READY_STATE_CHANGE] = script[STR_ON_LOAD] = script[STR_ON_ERROR] = null;
			head[STR_REMOVE_CHILD](script);
			scriptAfter && head[STR_REMOVE_CHILD](scriptAfter);
		};

		// Append main script
		head[STR_INSERT_BEFORE](script, firstChild = head.firstChild);

		// Append trailing script if needed
		scriptAfter && head[STR_INSERT_BEFORE](scriptAfter, firstChild);

		// If a timeout is needed, install it
		timeoutTimer = timeout > 0 && setTimeout(function () {
			notifyError(STR_TIMEOUT);
		}, timeout);
	}

	return xOptions;
}

// ###################### SETUP FUNCTION ##
jsonp.setup = function (xOptions) {
	$.extend(xOptionsDefaults, xOptions);
};

// ###################### INSTALL in jQuery ##
$.jsonp = jsonp;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

// import $ from 'jquery';
// import { merger } from "../helper_methods/merger.js";
/*
 * Author: Saeed
 * Version: v8.0.0
 * 
 * Updated By: Saeed
 * Description: [compatible for Web Component also]
 */

/*Start of Suggestor.js*/
var openDrops = {};
var trackingObject = {};
var trackingURL;
// var tObj = [];

function document_clickBind() {
    $(document).on('click.suggestor', function (e) {
        var closest = $(e.target).closest(".suggest");
        if (!openDrops[closest.attr('id')] || !closest.is(".suggest")) {
            $.each(openDrops, function (key, value) {
                var sugId = $(this).attr('id').split('_')[1];
                var sugInpNode = $(this).parent().find('.sugInp');
                var sInputVal = sugInpNode.val();
                if (sInputVal) sugInpNode.val(sInputVal.replace(/,\s*$/, ''));
                $(this).removeClass('slideDown');
                delete openDrops[sugId];
            });
        }
    });
}

var sugCache = ncCacheFactory.getCache('sgtr');
var checkLS = function checkLS() {
    if (typeof Storage !== "undefined") {
        return true;
    } else {
        return false;
    }
};

var sendBeacon = function sendBeacon(url, data) {
    var _data = JSON.stringify(data);
    if (navigator.sendBeacon && url) {
        navigator.sendBeacon(url, _data);
    } else if (checkLS()) {
        sugCache.setItem('sug_Tracking', data);
    }
};
var createTrackObject = function createTrackObject(textVal, position, typedValue, dataType, cached, Qry) {
    var obj;
    if (dataType == "autoconcepts") {
        obj = {
            "type": 'ac',
            "acFor": typedValue,
            "sel": textVal,
            "pos": position,
            "cached": cached
        };
    } else if (dataType == "relatedConcept") {
        obj = {
            "type": 'rc',
            "rcFor": Qry,
            "sel": textVal,
            "pos": position,
            "cached": cached
        };
    } else {
        obj = {
            "sel": textVal,
            "pos": position
        };
    }
    return obj;
};

var setTrackingObject = function setTrackingObject(id, textVal, position, typedValue, dataType, cached, Qry) {
    trackingObject[id] && trackingObject[id]['Events'].push(createTrackObject(textVal, position, typedValue, dataType, cached, Qry));
};

var sendTrackingData = function sendTrackingData() {
    /**  send data to server on window unload event by using sendBecon feature if exist,
     *   otherwise stored that data in localStorage and send in next user visit
     *   and also deleted if successfully send.
     */
    $('.sugInp').each(function (key, val) {
        var _this = $(this);
        var _params = _this.attr('trackParams');
        var inpVal = _this.val();
        var vertical;
        _params = _params ? $.parseJSON(_params) : null;
        if (_params) {
            if (inpVal || trackingObject[_params.id] && trackingObject[_params.id]['Events'].length) {
                if (!trackingObject[_params.id]['Events'].length) {
                    // tObj = [];
                    setTrackingObject(_params.id, inpVal, 0);
                }
                if (_params.sourceId) trackingObject[_params.id]['sId'] = _params.sourceId;
                if (_params.appId) trackingObject[_params.id]['appId'] = _params.appId;
                if (_params.platform) trackingObject[_params.id]['platform'] = _params.platform;
                if (_params.formId) trackingObject[_params.id]['formId'] = _params.formId;
                if (_params.trackingSrc) trackingObject[_params.id]['trackingSrc'] = _params.trackingSrc;

                vertical = _this.attr('vertical');
                //Send vertical also tracing logs
                if (vertical) trackingObject['vertical'] = vertical;
            } else {
                if (trackingObject[_params.id] && !trackingObject[_params.id]['Events'].length) {
                    delete trackingObject[_params.id];
                }
            }
        }
    });

    if (!$.isEmptyObject(trackingObject)) {
        sendBeacon(trackingURL, {
            "lgData": trackingObject
        });
    }
};

window.onunload = function () {
    sendTrackingData();
};

var suggestor = function suggestor(options) {

    if (!options.domain && !(options.url.autoComplete && options.url.relatedConcept && options.url.checkVersion && options.url.prefetch)) {
        throw Error("One or more mandatory parameters are missing, please refer documentation. https://github.com/saeed3e/suggestjs/blob/gh-pages/README.md");
        return false;
    }
    var defaults$$1 = {
        id: null,
        url: {
            autoComplete: options.domain + '/suggest/autosuggest?',
            relatedConcept: options.domain + '/suggest/autoconcepts?',
            checkVersion: options.domain + '/suggest/v?',
            prefetch: options.domain + '/suggest/prefetch?'
        },
        relatedConcept_dataLayer: true,
        autoCorrect_dataLayer: true,
        maxSuggestions: 15,
        maxHeight: 300,
        multiSearch: false,
        startSearchAfter: 1,
        suggestOnClick: false,
        whiteListSpecialChar: [],
        relatedCorrectionText: 'Did you mean ?',
        relatedConceptText: 'Related Skills',
        glbArray: false,
        placeholder: false,
        trackUserInteraction: false, // to track user Interaction
        grouping: true,
        isPrefetch: true,
        source: options.data ? 'local' : 'server',
        category: {},
        categoryOrder: [],
        qParams: {},
        searchLimit: {},
        relatedConceptCategory: null,
        getRelatedConcepts: null,
        onSelect: false,
        scrollStyle: '',
        width: null,
        preventClose: false,
        returnFocus: true,
        form: false, // deprecated 
        showDataOnFocus: false,
        storageKey: { // This parameter is used to store prefetched data agarint pretetchKey and version value against versionKey in localStorage.
            prefetchKey: '__suggest_prefetch',
            versionKey: '__suggest_versions'
        },
        userCookie: null,
        titleForSingleBucket: 'Last Searched Keywords',
        appId: null,
        relatedConceptsLimit: Infinity,
        defaultPrefetchLookup: true, // is set false then suggestor don't lookup defualt prefetch library.
        toolTip: false, // when true html title is provided to suggestions shown. Basically to show trimmed data.
        powerComments: false,
        // appendCommaAfterSelection:true
        appendCommaAtLast_onSelect: true,
        vertical: "",
        removeCommaAtLast_onBlur: true
    };

    for (var prop in options.category) {
        if (_typeof(options.category[prop]) === "object") {
            defaults$$1.category[prop] = defaults$$1.category[prop] || options.category[prop]["title"];
            defaults$$1.searchLimit[prop] = defaults$$1.searchLimit[prop] || options.category[prop];
            defaults$$1.categoryOrder.push(prop);
        } else {
            defaults$$1.category[prop] = options.category[prop] || defaults$$1.categoryOrder;
        }
    }
    options.categoryOrder = options.category["order"] || defaults$$1.categoryOrder;
    options.category = defaults$$1.category;
    options.searchLimit = defaults$$1.searchLimit;
    var params = $.extend(true, {}, defaults$$1, options);

    params.storageKey.userCookie = params.storageKey.userCookie || params.userCookie;

    // To prevent close when user click outside of suggestor's boudry
    if (!params.preventClose) {
        document_clickBind();
    }

    var makeAjax = function makeAjax(url, succCbFn, hideLoader) {
        if (url) {
            var _t = this;
            var id = _t.id;
            $.jsonp({
                "url": url + "&callback=suggestCallback",
                cache: true,
                callback: "suggestCallback",
                beforeSend: function beforeSend() {
                    if (!hideLoader) $('#' + id + ' .nLoder').show();
                },
                "success": function success(resp) {
                    _t.cached = false;
                    if (resp.resultList) {
                        if ($.isEmptyObject(resp.resultList) && _t.dropCont.hasClass('slideDown')) {
                            hide.call(_t);
                        } else {
                            _t.dataType = 'autoconcepts';
                            succCbFn(resp);
                            params.vertical = resp.vertical;
                            _t.inpElm.attr('vertical', params.vertical);
                        }
                    } else if (resp.resultConcepts) {
                        if ($.isEmptyObject(resp.resultConcepts)) {
                            hide.call(_t);
                        } else {
                            _t.dataType = 'relatedConcept';
                            if (params.getRelatedConcepts) params.getRelatedConcepts(resp, _t.Qry); // to pass related concept data in callback
                            if (params.relatedConcept_dataLayer) {
                                succCbFn(resp);
                            } else {
                                //Since sometime due to delay in request response, droplayer open again so, to prevent this nature again close the layer 
                                hide.call(_t);
                            }
                        }
                        _t.RCMaxCntr++;
                    } else if (resp.resultCorrections) {
                        if ($.isEmptyObject(resp.resultCorrections)) {
                            hide.call(_t);
                        } else {
                            _t.dataType = 'relatedConcept';
                            if (params.getAutoCorrect) params.getAutoCorrect(resp, _t.Qry); // to pass autoCorrect data in callback
                            if (params.autoCorrect_dataLayer) succCbFn(resp);
                        }
                        _t.RCMaxCntr++;
                    } else {
                        succCbFn(resp);
                    }
                },
                complete: function complete() {
                    _t.node.find('.nLoder').hide();
                },
                "error": function error(d, msg) {
                    _t.node.find('.nLoder').hide();
                    hide.call(_t);
                }
            });
        }
    };

    var prefetchData_personalized = function prefetchData_personalized() {
        var _t = this;
        _t.rs_kWrds = [];
        _t.rs_kWrdsStr = '';
        var recentSearches = params.showDataOnFocus;
        if (recentSearches) {
            _t.rs_kWrds = recentSearches;
            if (_t.rs_kWrds.length) {
                _t.rs_kWrdsStr = _t.rs_kWrds.join(',').replace(/\s,|,\s/g, ',');
            }
        }

        var prefData = params.storageKey;
        _t.isLoggedIn = prefData.userCookie ? getCookie(prefData.userCookie) : false;
        var vertical = params.vertical ? '&vertical=' + params.vertical : '';
        //var qParamString = !$.isEmptyObject(params.qParams) ? '&'+$.param(params.qParams):'';
        var qParamString = getQparam();

        if (_t.isLoggedIn) {
            return {
                key: prefData.prefetchKey + '/uId/' + _t.isLoggedIn,
                url: params.url.prefetch + '&' + Math.random(1, 100) + '&keywords=' + _t.rs_kWrdsStr + '&uid=' + _t.isLoggedIn + vertical + qParamString,
                keywords: _t.rs_kWrdsStr
            };
        } else if (_t.rs_kWrdsStr) {
            return {
                key: prefData.prefetchKey,
                url: params.url.prefetch + '&' + Math.random(1, 100) + '&keywords=' + _t.rs_kWrdsStr + vertical + qParamString,
                keywords: _t.rs_kWrdsStr
            };
        } else {
            return {
                key: prefData.prefetchKey,
                url: params.url.prefetch + '&' + Math.random(1, 100) + '&keywords=' + vertical + qParamString,
                keywords: _t.rs_kWrdsStr
            };
        }
    };

    var mergeData = function mergeData(oldD, newD) {
        params.vertical = newD.vertical;
        if (params.vertical) {
            var newAC = newD.ac,
                newRC = newD.rc;

            var category = params.category;
            var rcCategory = params.relatedConceptCategory;
            for (key in newAC) {
                for (k in newAC[key]) {
                    if (category[k]) {
                        var premKey = k + "_" + params.vertical;

                        newAC[key][premKey] = newAC[key][k];
                        delete newAC[key][k];
                    } else {
                        delete newAC[key][k];
                    }
                }
            }
            for (key in newRC) {
                for (k in newRC[key]) {
                    if (rcCategory[k]) {
                        var premKey = k + "_" + params.vertical;
                        newRC[key][premKey] = newRC[key][k];
                        delete newRC[key][k];
                    } else {
                        delete newRC[key][k];
                    }
                }
            }
            var ac = $.extend(true, {}, oldD.ac, newAC);
            var rc = $.extend(true, {}, oldD.rc, newRC);
        } else {
            var ac = $.extend(true, {}, oldD.ac, newD.ac);
            var rc = $.extend(true, {}, oldD.rc, newD.rc);
        }

        return {
            'ac': ac,
            'rc': rc,
            "ttl": newD.ttl,
            "segments": newD.segments,
            "keyword_based_data": newD.keyword_based_data

        };
    };

    var callPrefetchData = function callPrefetchData() {
        var _t = this;
        params.url.checkVersion += Math.random(0, 100);
        _t.prefetchObj = prefetchData_personalized.call(_t);

        // isFirstCall : if multiple suggestor call in a page then version checks only one time.
        if (!window.isFistCall && params.url.prefetch && checkLS() && params.isPrefetch) {
            makeAjax.call(_t, params.url.checkVersion, function (resp) {

                setLS(params.storageKey.versionKey, resp);
                var isData = sugCache.getItem(_t.prefetchObj.key);
                if (isData) {
                    /**
                     * [if description]
                     * @param  {String} isData.keyword_based_data [need to check with blank string,
                     * because in some cases false is treated as a true]
                     */
                    if (_t.prefetchObj.keywords && isData.keyword_based_data === false || +new Date(isData.ttl) - +new Date() < 0) {
                        makeAjax.call(_t, _t.prefetchObj.url + '&segments=' + isData.segments, function (pData) {
                            setLS(_t.prefetchObj.key, mergeData(isData, pData));
                        });
                    }
                } else {
                    var isDataExist = sugCache.getItem(params.storageKey.prefetchKey);
                    var segm = isDataExist ? isDataExist.segments : '';
                    makeAjax.call(_t, _t.prefetchObj.url + '&segments=' + segm, function (pData) {
                        setLS(_t.prefetchObj.key, pData);
                    }, true);
                }
            }, true);
            window.isFistCall = true;
        }
    };

    var setCaretPos = function setCaretPos(input, pos) {
        // need to rewrite this function
        var selectionStart = pos,
            selectionEnd = pos;
        if (input.setSelectionRange) {
            input.focus();
            input.setSelectionRange(selectionStart, selectionEnd);
        } else if (input.createTextRange) {
            var range = input.createTextRange();
            range.collapse(true);
            range.moveEnd('character', selectionEnd);
            range.moveStart('character', selectionStart);
            range.select();
        }
    };

    var decodeTxt = function decodeTxt(txt) {
        //'Unit Test Done':
        return txt ? txt.replace(/(<([^>]+)>)/ig, "").replace(/&amp;/gi, '&') : "";
    };

    var txtAfterLastComma = function txtAfterLastComma(z) {
        z = $.trim(z).toLowerCase();
        z = $.trim(z.substring(z.lastIndexOf(',') + 1, z.length));
        return z;
    };

    var txtBeforeLastComma = function txtBeforeLastComma(val) {
        var z = $.trim(val).replace(/,*$/g, '');
        return $.trim(z.substring(z.lastIndexOf(',') + 1, z.length)).toLowerCase();
    };

    var setLS = function setLS(key, data) {
        sugCache.setItem(key, data);
    };

    var getLS = function getLS(key, type) {
        if (this.prefetchObj) {
            var d = sugCache.getItem(this.prefetchObj.key);
            if (params.defaultPrefetchLookup && (!d || !d[type] || !d[type][key])) {
                d = sugCache.getItem(params.storageKey.prefetchKey);
            }
            return d ? d[type][key] : false;
        } else {
            return false;
        }
    };

    var removeComma = function removeComma() {
        var _t = this;
        var sInputVal = _t.inpElm.val();
        if (sInputVal) _t.inpElm.val(sInputVal.replace(/,\s*$/, ''));
    };

    var addComma = function addComma(txt) {
        //'Unit Test Done':     
        var _t = this;
        var str = _t.inpElm.val();
        var nStr = str.substring(0, str.lastIndexOf(',') + 1);
        nStr = nStr ? nStr + ' ' : '';
        txt = $.trim(decodeTxt(txt).replace(/,*$/g, ''));
        return params.multiSearch ? nStr + txt + ', ' : txt;
    };

    var getIndex = function getIndex(elm, parent) {
        return $.inArray(elm[0], parent.find('li.sugTouple')) + 1;
    };

    var setValueInTextBox = function setValueInTextBox(btn, relatedConceptFlag) {
        var _t = this;
        var id = _t.id;
        var elm = _t.inpElm;
        var txt = btn.text();
        var custVal = function () {
            if (params.localSuggestions) {
                return function (lastchar) {
                    //'Unit Test Done':    this function gets last character after comma
                    var str = _t.trimSpace(lastchar);
                    var isDelimiterAtLast = str.match(/\W(\w)*$/g);
                    if (isDelimiterAtLast) {
                        var delimiter = isDelimiterAtLast[0].charAt(0);
                        if (params.localSuggestions.removeRepetedDelimiter) {
                            str = str.replace(new RegExp(delimiter + '+$', 'g'), delimiter);
                        }
                        return str.substring(0, str.lastIndexOf(delimiter) + 1) + txt + " ";
                    } else {
                        // return addComma.call(_t, txt);
                        return txt;
                    }
                }(elm.val());
            } else {
                return addComma.call(_t, txt);
            }
        }();

        _t.enableRC_for_onfocus = false;

        if (custVal.length < params.maxlength) {
            elm.val(custVal);
            if (params.trackUserInteraction) {
                // tObj = [];
                setTrackingObject(id, txtAfterLastComma(custVal.replace(/[,\s]*$/, '')), _t.posIndex, txtAfterLastComma(_t.queryChar), _t.dataType, _t.cached, _t.Qry);
            }
            if (params.returnFocus) setCaretPos(elm[0], elm.val().length);
            if (relatedConceptFlag) _t.get_RCdata(elm.val());
            if (params.onSelect) params.onSelect(id, decodeTxt(txt), elm, _t);
        } else {
            if (params.onSelect) params.onSelect(id, "Warning: maximum length reached", elm, _t);
        }
        hide.call(_t);
    };

    var multiSearchOnOff = function multiSearchOnOff(sel) {
        // no Unit Test
        var _t = this;
        var li = _t.dropCont.find(sel);
        li = li.hasClass('category') ? li.next() : li;
        return li;
    };

    var removeHighligting = function removeHighligting(elm) {
        if (elm) elm.find('.sAct').removeClass('sAct');
    };

    var currActElm = function currActElm(node, PevNxt) {
        // handled on arrow key up and down
        var _t = this;
        var prevNode = node;
        if (PevNxt == "prev") {
            if (node.prev().hasClass('category')) {
                if (node.prev().prev().length) {
                    node = node.prev().prev();
                } else {
                    node = multiSearchOnOff.call(_t, ' li:last-child');
                }
            } else {
                if (node.prev().length) {
                    node = node.prev();
                } else {
                    node = multiSearchOnOff.call(_t, ' li:last-child');
                }
            }
        } else if (!node.next().length) {
            node = multiSearchOnOff.call(_t, ' li:first-child');
        } else if (node.next().hasClass('category')) {
            node = node.next().next();
        } else {
            node = node.next();
        }
        if (_t.curElm.find('.Sarw').hasClass('sAct')) {
            node.find('.Sarw').addClass('sAct');
        } else {
            node.find('.Sbtn').addClass('sAct');
        }
        removeHighligting(prevNode);
        if (!params.multiSearch) _t.inpElm.val(decodeTxt(node.find('.Sbtn').html()));
        return node;
    };

    var gotoFirstLast = function gotoFirstLast(sel, node) {
        // handled on arrow key up and down
        var _t = this;
        node = $('#' + sel);
        node = node.hasClass('category') ? node.next() : node;
        node.find('.Sbtn').addClass('sAct');
        if (!params.multiSearch) _t.inpElm.val(decodeTxt(node.find('.Sbtn').html()));
        return node;
    };

    var FilterCommon = function FilterCommon(dataOb, lastchar) {
        //'Unit Test Done':   
        var _t = this;
        //firstPart, secondPart = '';
        var dataAryAt;
        if ((typeof dataOb === "undefined" ? "undefined" : _typeof(dataOb)) == "object") {
            dataAryAt = dataOb.displayTextEn;
        } else {
            dataAryAt = dataOb;
        }

        var Li = '',
            new1 = '',
            e = '',
            new2 = '';
        dataAryAt = dataAryAt.replace(/&amp;/gi, '&');
        if (lastchar.split(',')[1] && params.multiSearch) {
            lastchar = _t.getlastChar(lastchar);
        }
        lastchar = lastchar.replace(/[\s]+/g, " ").replace(/^\s/, "").toLowerCase();
        var str = dataAryAt,
            strL = str.toLowerCase(),
            getPos = strL.indexOf(lastchar),
            strLower = strL,
            sTxtValueLower = lastchar,
            spaceVal = strLower.indexOf(' ' + sTxtValueLower) < 0 ? false : strLower.indexOf(' ' + sTxtValueLower),
            bracketVal = strLower.indexOf('(' + sTxtValueLower) < 0 ? false : strLower.indexOf('(' + sTxtValueLower),
            slashVal = strLower.indexOf('/' + sTxtValueLower) < 0 ? false : strLower.indexOf('/' + sTxtValueLower);
        if (getPos >= 0 && (spaceVal || bracketVal || slashVal) || getPos === 0) {
            if (getPos) {
                if (spaceVal) {
                    getPos = spaceVal + 1;
                } else if (bracketVal) {
                    getPos = bracketVal + 1;
                } else if (slashVal) {
                    getPos = slashVal + 1;
                }
            }
            new1 = str.substr(0, getPos);
            e = str.substr(getPos, lastchar.length);
            new2 = '<strong>' + str.substr(getPos + lastchar.length, str.length) + '</strong>';
        }
        e = e ? e : dataAryAt;
        var combined_Text;
        if (lastchar) {
            combined_Text = new1 + e + new2;
        } else {
            combined_Text = e;
        }
        // if (lastchar) var splitedData = dataAryAt.toLowerCase().split(lastchar.toLowerCase());

        // if ($.isArray(splitedData)) {
        //     if (splitedData.length == 1) {
        //         firstPart = dataAryAt;
        //     } else {
        //         firstPart = splitedData[0] + lastchar;
        //         secondPart = '<strong>' + splitedData[1] + '</strong>';
        //     }

        // } else {
        //     firstPart = dataAryAt;
        // }
        var title = params.toolTip ? new1 + e + new3 : '';
        var arwDiv = params.suggestOnClick ? '<div class="wrapTable"><div tabindex="-1" class="Sbtn" title="' + title + '">' + new1 + e + new2 + '</div></div><span class="Sarw"></span>' : '<div tabindex="-1" class="Sbtn" title="' + title + '" style="width:100%">' + combined_Text + '</div>';

        //var arwDiv = params.suggestOnClick ? '<div class="wrapTable"><div tabindex="-1" class="Sbtn">' + firstPart + secondPart + '</div></div><span class="Sarw"></span>' : '<div tabindex="-1" class="Sbtn" style="width:100%">' + firstPart + secondPart + '</div>';

        Li = '<li class="sugTouple">' + arwDiv + '</li>';
        return Li;
    };

    var dataOrdering = function dataOrdering(data, categoryObj) {
        var newObj = {},
            flg = 0,
            xV = '';

        // if(params.localSuggestions){
        //     newObj = data;
        // }else{
        for (var x in categoryObj) {
            if (params.vertical) {
                xV = x + "_" + params.vertical;
            }
            if (data[xV] || data[x]) {
                newObj[x] = data[xV] || data[x];
                flg++;
            }
        }
        // }

        return [newObj, flg];
    };

    var Filter = function Filter(lastchar, dataAry, relConcpt, catgObj) {
        var _t = this;
        var fLi = '';
        var resp;

        if (!catgObj) {
            if (relConcpt == "resultConcepts") {
                catgObj = params.relatedConceptCategory;
                // } else if (relConcpt == "autoComplete") {
                //     catgObj = params.category;
            } else {
                catgObj = params.category;
            }
        }

        // This is temporary fix : optimize solution is in v7.2.0
        if (!relConcpt && params.showTitleForSingleBucket) {
            resp = dataOrdering(dataAry, {
                'rs': 'rs'
            });
        } else {
            resp = dataOrdering(dataAry, catgObj);
        }

        var flg = resp[1];
        dataAry = resp[0];
        var Li = '';
        var inpVal = "";

        lastchar = lastchar.replace(/&amp;/gi, '&');
        if ($.isEmptyObject(params.searchLimit)) {
            for (var i in dataAry) {
                var maxSuggestionCounter = 0;
                for (var z in dataAry[i]) {
                    if (relConcpt || maxSuggestionCounter++ < params.maxSuggestions) {
                        // show max number of suggestion specified in plugin call
                        inpVal = _t.inpElm.val().replace(/\s,/g, ',').replace(/,\s/g, ',').toLowerCase();

                        if (inpVal.indexOf(',') == -1 || $.inArray(dataAry[i][z].displayTextEn.toLowerCase(), inpVal.split(',')) == -1) {
                            // exclude the value which already in search box
                            Li += FilterCommon.call(_t, dataAry[i][z], lastchar);
                        } else {
                            continue;
                        }
                    }
                }
                if (Li && flg > 1) {
                    if (params.grouping) {
                        fLi += '<li class="category ' + i + '">' + (params.category[i] ? params.category[i] : i) + '</li>' + Li;
                    } else {
                        fLi += Li;
                    }
                } else if (!relConcpt && params.showTitleForSingleBucket) {
                    fLi += '<li class="category ' + i + '">' + 'Last Searched Keywords' + '</li>' + Li;
                } else {
                    fLi = Li;
                }
            }
        } else {
            for (var idx = 0; idx < params.categoryOrder.length; idx++) {
                if (dataAry.hasOwnProperty(params.categoryOrder[idx])) {
                    var dataLength = dataAry[params.categoryOrder[idx]].length > parseInt(params.searchLimit[params.categoryOrder[idx]]["limit"]) ? parseInt(params.searchLimit[params.categoryOrder[idx]]["limit"]) : dataAry[params.categoryOrder[idx]].length;

                    for (var j = 0; j < dataLength; j++) {
                        inpVal = _t.inpElm.val().replace(/\s,/g, ',').replace(/,\s/g, ',').toLowerCase();
                        if (inpVal.indexOf(',') == -1 || $.inArray(dataAry[params.categoryOrder[idx]][j].displayTextEn.toLowerCase(), inpVal.split(',')) == -1) {
                            // exclude the value which already in search box
                            Li += FilterCommon.call(_t, dataAry[params.categoryOrder[idx]][j], lastchar);
                        } else {
                            continue;
                        }
                    }
                    if (Li) {
                        if (params.grouping) {
                            fLi = '<li class="category ' + params.categoryOrder[idx] + '">' + (params.searchLimit[params.categoryOrder[idx]]["title"] ? params.searchLimit[params.categoryOrder[idx]]["title"] : params.categoryOrder[idx]) + '</li>' + Li;
                        } else {
                            fLi = Li;
                        }
                    } else if (!relConcpt && params.showTitleForSingleBucket) {
                        fLi = '<li class="category ' + params.categoryOrder[idx] + '">' + 'Last Searched Keywords' + '</li>' + Li;
                    } else {
                        fLi = Li;
                    }
                }
            }
        }
        if (!$.isEmptyObject(dataAry)) {
            if (relConcpt == "resultCorrections") {
                fLi = '<li class="category">' + params.relatedCorrectionText + '</li>' + fLi;
            } else if (relConcpt == "resultConcepts") {
                fLi = '<li class="category">' + params.relatedConceptText + '</li>' + fLi;
            }
        }
        return fLi;
    };

    var setPlaceHolder = function setPlaceHolder() {
        var _t = this;
        var elm = _t.inpElm;
        params.placeholderTxt = elm ? elm[0].getAttribute('placeholder') : '';
        elm.val(params.placeholderTxt);
        // .css({
        //     'color': '#8B8B8B'
        // });
    };

    var hidePlaceHolder = function hidePlaceHolder() {
        var _t = this;
        _t.inpElm.val('').css({
            'color': '#444'
        });
    };

    var setResponse = function setResponse(resp, val) {
        this.showSugt({ val: val, data: resp.resultList, relConcpt: 'autoComplete' });
    };

    var categoryList = function categoryList(relConcpt, queryLength) {
        var txt = '';
        var catagory;
        var queryLength = queryLength || 0;
        if (relConcpt) {
            catagory = params.relatedConceptCategory;
        } else {
            catagory = params.category;
        }
        for (var x in catagory) {
            if (!relConcpt && params.searchLimit[x]) {
                if (params.searchLimit[x]["startSearchAfter"]) {
                    if (queryLength >= params.searchLimit[x]["startSearchAfter"]) {
                        txt += x + ',';
                    }
                } else {
                    txt += x + ',';
                }
            } else {
                txt += x + ',';
            }
        }
        return txt.replace(/,$/g, '');
    };

    var getQparam = function getQparam() {
        return !$.isEmptyObject(params.qParams) ? '&' + $.param(params.qParams) : '';
    };

    var encodeURL = function encodeURL(url, queryText, relConcptFlag) {
        var _t = this;
        var version = '';
        var appId = params.appId ? "&appId=" + params.appId : '';
        var sourceId = params.sourceId ? '&sourceId=' + params.sourceId : '';
        var patr = new RegExp('[^a-zA-Z0-9,\\s' + params.whiteListSpecialChar + ']', 'g');
        _t.Qry = queryText.replace(patr, '');
        if (_t.Qry) {
            if (checkLS() && _t.prefetchObj) {
                var versionObj = sugCache.getItem(params.storageKey.versionKey);
                var version = versionObj ? '&version=' + versionObj.suggester_v : "";
                //if (sugVersoin) version = '&version=' + sugVersoin;
            }
            return url + "query=" + encodeURIComponent(_t.Qry) + appId + '&vertical=' + params.vertical + '&category=' + categoryList.call(_t, relConcptFlag, _t.Qry.length) + '&limit=' + params.maxSuggestions + sourceId + version + getQparam();
        } else {
            return false;
        }
    };

    var checkDatainLocalStorage = function checkDatainLocalStorage(queryText, type, category) {
        var isData = 0,
            getData;
        if (queryText && checkLS()) {
            //var startX = (new Date).getMilliseconds()
            getData = getLS.call(this, queryText, type);
            if (getData) {
                for (var q in category) {
                    // if (params.vertical) {
                    //     qv = q + "_" + params.vertical;
                    //     if (getData[qv]) {
                    //         isData = 1;
                    //         this.cached = true;
                    //     }
                    // } else {
                    if (getData[q]) {
                        isData = 1;
                        this.cached = true;
                    }

                    // }
                }
            }
        }
        return [isData, getData];
    };

    var onSuggest = function onSuggest() {
        var _t = this;
        return function (e) {
            var _T = $(this);
            var selector;
            var reference;
            var flag;
            if ($(e.target).hasClass('Sarw')) {
                selector = $(e.target).parents('li');
                flag = true;
            } else if ($(e.target).hasClass('Sbtn') || $(e.target).is('strong')) {
                selector = $(e.target).closest('li');
                flag = params.suggestOnClick ? false : true;
            }
            reference = selector.find('.Sbtn');
            if (!params.relatedConceptCategory || _t.RCMaxCntr >= params.relatedConceptsLimit - 1) {
                // prevent RC after 'n' number of RC
                flag = false;
                hide.call(_t);
            }
            _t.posIndex = getIndex(selector, _t.dropCont);
            if (params.suggestOnClick) hide.call(_t);

            // "50ms Timeout": This timeout is to give first prioriry to document click (click.suggestor) to capture closest node easily.
            // Reason: Whenever a click is fired on document and we want to capture closest element using code : "$(event.target).closest(".suggest")"
            // then we lose that closest element because that targeted element either hide or displaced from it's original position
            // So to overcome this problem we set "50 ms" timeout to easily capture closest selector.
            setTimeout(function () {
                setValueInTextBox.call(_t, reference, flag);
            }, 50);
        };
    };

    var hide = function hide() {
        var _t = this;
        var id = _t.id;
        removeHighligting(_t.curElm);
        // _t.dropCont.slideUp(100);
        _t.dropCont.removeClass('slideDown');
        _t.curElm = '';
        $('#' + id).find('.sWrap').removeClass('sOpen').addClass('sHide');
        delete openDrops[id];
        if (params.onHide) params.onHide();

        /*This timeout give assurance that flag only set when suggestor completely closed*/
        setTimeout(function () {
            _t.enableRC_for_onfocus = true;
        }, 500);
    };

    var show = function show() {
        var _t = this;
        var id = _t.id;
        if (params.width) {
            _t.wth = params.width;
        } else {
            _t.wth = $(document.getElementById(id)).outerWidth() + 'px';
        }
        _t.dropCont.css({
            'width': _t.wth
        }).addClass('slideDown');
        $('#' + id).find('.sWrap').removeClass('sHide').addClass('sOpen');
        openDrops[id] = _t.dropCont;
        if (params.onShow) params.onShow();
    };

    var liEvnBind = function liEvnBind() {
        var _t = this;
        _t.dropCont.on('mouseover', '.Sbtn,.Sarw,strong', function (e) {

            if ($(this).hasClass('Sbtn')) {
                $(this).addClass('sAct');
            } else if ($(this).is('strong')) {
                $(this).parent().addClass('sAct');
            } else {
                $(this).addClass('sAct');
            }

            removeHighligting(_t.curElm);
            _t.curElm = $(this);
        }).mouseout(function (e) {
            _t.curElm = undefined;
            removeHighligting($(this));
        });
    };

    var bindClick = function bindClick(e) {
        var targ = e.target || e.srcElement;
        if ($(targ).hasClass('inpWrap')) {
            $(this).find('.sugInp').focus();
        }
    };

    var convertRawData_toDataObject = function convertRawData_toDataObject() {
        var dOb = {};
        var dAry = [];

        for (var x in this.rs_kWrds) {
            dAry.push({
                "displayTextEn": this.rs_kWrds[x]
            });
        }
        //dOb['rs'] = params.showDataOnFocus;
        dOb['rs'] = dAry;
        return dOb;
    };

    var bindFocus = function bindFocus(e) {
        var _t = this;
        var val = $.trim(_t.inpElm.val());
        _t.curOpenSugg = _t.id;
        if (params.showDataOnFocus) {
            if (!$.trim(_t.inpElm.val())) {
                params.category = $.extend({}, params.category, {
                    'rs': 'rs'
                });
                if (_t.rs_kWrdsStr) {
                    this.showSugt({ val: '', data: convertRawData_toDataObject.call(_t) });
                } else {
                    prefetchData_personalized.call(_t);
                    if (_t.rs_kWrdsStr) this.showSugt({ val: '', data: convertRawData_toDataObject.call(_t) });
                }
            }
        }

        if (params.multiSearch && val && val != params.placeholderTxt) {
            var characterTobeAppend = void 0;

            if (params.appendCommaAtLast_onSelect) {
                characterTobeAppend = ", ";
            } else {
                characterTobeAppend = " ";
            }

            setTimeout(function () {
                _t.inpElm.val(val.replace(/[,\s]*$/, characterTobeAppend));
            }, 10); // to handle browser's cursor position issue

            // to show relatedConcepts if comma is present after keyword
            if (params.relatedConceptCategory && _t.enableRC_for_onfocus && _t.RCMaxCntr < params.relatedConceptsLimit - 1) {
                _t.get_RCdata(txtBeforeLastComma(val));
            }
        } else if (!$.support.placeholder && params.placeholder && params.placeholderTxt == val) {
            hidePlaceHolder.call(_t);
        }
    };

    /**
     * [getKeyCode description :for android chrome keycode fix]
     * @return {[type]} [keycode value]
     */
    var getKeyCode = function getKeyCode() {
        var str = this.val();
        return str.charCodeAt(str.length - 1);
    };

    var keyUpEv = function keyUpEv(inpObj, e) {
        var _t = this;
        var Id = inpObj.attr('id');
        var kCd = e.keyCode || e.which;
        if (kCd == 0 || kCd == 229) {
            //for android chrome keycode fix
            kCd = getKeyCode.call(inpObj);
        }
        var sugInputElm = _t.inpElm;
        var id = _t.id;
        //var patr = new RegExp('[^a-zA-Z0-9,\\s' + params.whiteListSpecialChar + ']', 'g');
        var val = $.trim(sugInputElm.val());

        _t.queryChar = val;
        if (kCd == 13 && _t.dropCont.css('display') == "block") {
            if (!_t.curElm) {
                hide.call(_t);
            } else {
                _t.posIndex = getIndex(_t.curElm, _t.dropCont);
                var relConcpt_flag;

                if (!params.relatedConceptCategory || _t.RCMaxCntr >= params.relatedConceptsLimit - 1) {
                    relConcpt_flag = false;
                    _t.RCMaxCntr++;
                } else if (params.suggestOnClick && _t.curElm.find('.Sbtn').hasClass('sAct')) {
                    relConcpt_flag = false;
                } else {
                    relConcpt_flag = true;
                }
                setValueInTextBox.call(_t, _t.curElm.find('.Sbtn'), relConcpt_flag);
                if (!relConcpt_flag) hide.call(_t);
            }
        } else if (kCd == 27) {
            hide.call(_t);
        } else if (!val && (kCd == 8 || kCd == 46)) {
            // on backspace or delete btn
            $('#' + id + ' .sCross').hide();
            hide.call(_t);
        } else if (kCd >= 48 && kCd < 90 || kCd >= 97 && kCd <= 122 || kCd == 16 || kCd == 188 || kCd == 8) {
            if (e.ctrlKey && kCd === 86) {
                //to handle on paste case (ctrl+v)
                val = val.replace(/,$/, '');
                sugInputElm.val(val);
            }
            if (val) {
                var matchedDelimiter = void 0;
                if (params.localSuggestions) {
                    var regex = '[' + params.localSuggestions.delimiter.join('') + '](\\w)*$';

                    var delimiters = new RegExp(regex, 'g');

                    matchedDelimiter = val.match(delimiters);

                    if (matchedDelimiter) {
                        this.showSugt({ val: matchedDelimiter[0].substring(1, matchedDelimiter[0].length), data: this.getLocalSuggestions(matchedDelimiter[0], val), catagory: { 'tempCategory': 'tempCategory' } });
                        return;
                    }
                }

                if (params.source == "server") {
                    if (kCd == 188 && val.lastIndexOf(',') != -1 && params.multiSearch) {
                        // on Comma
                        if (params.relatedConceptCategory) {
                            _t.get_RCdata(txtBeforeLastComma(val));
                        } else {
                            hide.call(_t);
                        }
                    } else {
                        var trimVal = params.multiSearch ? this.extractTextAfterLastDelimiter(val) : val;
                        if (trimVal.length > params.startSearchAfter - 1) {
                            var vData = checkDatainLocalStorage.call(_t, trimVal, 'ac', params.category);
                            if (vData[0]) {
                                if (params.bypassPrefetchAfter && params.bypassPrefetchAfter <= parseInt(trimVal.length)) {
                                    _t.getAutoCompletes(val, trimVal);
                                } else {
                                    _t.dataType = 'autoconcepts';
                                    this.showSugt({ val: trimVal, data: vData[1], relConcpt: 'autoComplete' });
                                }
                            } else {
                                _t.getAutoCompletes(trimVal, trimVal);
                            }
                        }
                    }
                } else if (params.source == "local") {
                    _t.returnDataArray({ data: params.data, val: val });
                }
            }

            //Need to evalute this piece again.......since its inside keyup event
            $('#' + id).find('.sCross').show().click(function () {
                _t.inpElm.val('').focus();
                $(this).hide();
                hide.call(_t);
                _t.dropCont.find('ul').html('');
            });
            // End of comment
        } else if (e.ctrlKey && kCd == 39 || e.ctrlKey && kCd == 40) {

            _t.curElm.find('.Sbtn').removeClass('sAct');
            _t.curElm.children('.Sarw').addClass('sAct');
        } else if (e.ctrlKey && kCd == 37 || e.ctrlKey && kCd == 38) {

            _t.curElm.children('.Sarw').removeClass('sAct');
            _t.curElm.find('.Sbtn').addClass('sAct');
        } else if (_t.dropCont.find('li').length) {
            if (_t.dropCont.css('display') == "none" && kCd == 40) {
                show.call(_t);
            } else {
                if (kCd == 38) {
                    if (_t.curElm) {
                        _t.curElm = currActElm.call(_t, _t.curElm, 'prev');
                    } else {
                        _t.curElm = gotoFirstLast.call(_t, id + ' li:last-child', _t.curElm);
                    }
                    show.call(_t);
                } else if (kCd == 40) {
                    if (_t.curElm) {
                        _t.curElm = currActElm.call(_t, _t.curElm, 'next');
                    } else {
                        _t.curElm = gotoFirstLast.call(_t, id + ' li:first-child', _t.curElm);
                    }
                }
            }
        }
    };

    var keyDnEv = function keyDnEv(e) {
        var _t = this;
        var kCd = e.which || e.keyCode;
        if (kCd == 38) {
            e.preventDefault();
        } else if (kCd == 13) {
            //Enter is prevent Default when an item in suggestor is under selection
            if (_t.dropCont.css('display') == "block" && _t.curElm) {
                e.preventDefault();
            }
        } else if (kCd == 9) {
            if (_t.curElm) {
                var setVal = _t.curElm.html().replace(/(<([^>]+)>)/ig, "").replace(/&amp;/gi, '&');
                _t.inpElm.val(addComma.call(_t, setVal));
            }
            removeComma.call(_t);
            hide.call(_t);
        }
    };

    var assignment = function assignment(node) {
        var _t = this,
            tParam;
        trackingURL = params.url.trackingURL; // set tracking URL to a global variable, to access it in "unload" event;
        _t.id = params.id || node.attr('id');
        _t.enableRC_for_onfocus = true; // This flag is for "to enable RC on focus, if any keyword exist in search box".
        _t.RCMaxCntr = 0;
        _t.inpElm = node.find('.sugInp');
        params.placeholderTxt = _t.inpElm.attr('placeholder');

        trackingObject[_t.id] = {}; // for central tracking 
        trackingObject[_t.id]['Events'] = []; // for central tracking 

        // If tracking enabled then set some parameters on suggetor input node for future reference
        if (params.trackUserInteraction) {
            tParam = {
                'trackParams': JSON.stringify({
                    "id": _t.id ? _t.id : "",
                    "sourceId": params.sourceId ? params.sourceId : "",
                    "platform": params.platform ? params.platform : "",
                    "appId": params.appId ? params.appId : "",
                    "trackingSrc": params.trackingSrc ? params.trackingSrc : ''
                })
            };
        }

        _t.inpElm.attr($.extend({
            "autocomplete": "off"
        }, tParam));

        params.maxlength = _t.inpElm.attr('maxlength') || 10000;

        _t.dropCont = $('<div class="sugCont ' + params.scrollStyle + '" id="sugDrp_' + _t.id + '">').append('<ul class="Sdrop"></ul>');
        node.append(_t.dropCont);

        if (params.placeholder && !$.support.placeholder && !$.trim(_t.inpElm.val())) {
            setPlaceHolder.call(this);
        }

        //Bind focus handler on suggestor input node
        _t.inpElm.focus(function () {
            bindFocus.call(_t);
        }).keyup(function (e) {
            keyUpEv.call(_t, $(this), e);
        }).keydown(function (e) {
            if (!_t.curOpenSugg) {
                // to handle bug for: if suggestor not initialized and user already foucs on suggestor
                _t.curOpenSugg = _t.id;
            }
            keyDnEv.call(_t, e);
        });

        if (params.removeCommaAtLast_onBlur) {
            _t.inpElm.blur(function () {
                this.value = this.value.replace(/[,\s]*$/, '');
            });
        }

        //Bind click handler on suggestor input node
        node.find('.sWrap').click(bindClick);

        //Bind event on list nodes
        liEvnBind.call(_t);

        //Bind click handler on suggestor drop listing nodes
        _t.dropCont.on('click', '.sugTouple', onSuggest.call(_t));

        //Get version and prefetch data
        callPrefetchData.call(_t);

        //This code of block is for to send tracking object to server
        if (params.trackUserInteraction && checkLS() && trackingURL) {
            var trackingData = sugCache.getItem('sug_Tracking');
            if (trackingData) {
                makeAjax.call(_t, trackingURL + '?lgData=' + JSON.stringify(trackingData), function () {
                    sugCache.removeItem('sug_Tracking');
                });
            }
        }
    };

    //Constructor
    var initialization = function initialization(node) {
        this.node = node;
        assignment.call(this, node);
        this.setTrackingObject = setTrackingObject;
    };

    initialization.prototype = function () {
        var getValue = function getValue(argument) {
            return this.inpElm.val();
        };

        var get_RCdata = function get_RCdata(val) {
            var _t = this;
            var z = _t.getlastChar(val);
            var vData = checkDatainLocalStorage.call(_t, z, 'rc', params.relatedConceptCategory);
            if (vData[0]) {
                hide.call(_t);
                _t.dataType = 'relatedConcept';

                this.showSugt({ val: z, data: vData[1], relConcpt: 'resultConcepts' });
                _t.RCMaxCntr++;
            } else {
                var URL = encodeURL.call(_t, params.url.relatedConcept, z, true);
                makeAjax.call(_t, URL, function (resp) {
                    hide.call(_t);
                    for (var x in resp) {}
                    this.showSugt({ val: z, data: resp[x], relConcpt: x });
                });
            }
        };

        var getLocalSuggestions = function getLocalSuggestions(delimiter, queryText) {
            var totalFilteredSuggestion = 0;
            var valAfterDelimiter = queryText.match(/[#@](\w)*$/g)[0].replace(/^[#@]/, '').toLowerCase();

            // var queryText_lowerCase = queryText.toLowerCase();            
            var ptr = new RegExp('^' + [valAfterDelimiter] + '|\\s' + [valAfterDelimiter]);

            var data = params.localSuggestions.data(delimiter[0]).filter(function (val, index) {
                if (totalFilteredSuggestion < params.maxSuggestions) {
                    if (!valAfterDelimiter || val.displayTextEn.toLowerCase().match(ptr)) {
                        return true;
                        totalFilteredSuggestion++;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            });

            return {
                tempCategory: data
                // tempKey: returnDataArray.call(_this, {
                //     data: [{'tempkey':params.localSuggestions.data(delimiter[0])}],
                //     val
                // })
            };
        };

        var returnDataArray = function returnDataArray(_ref) {
            var sourceData = _ref.data,
                queryText = _ref.val;

            var _t = this;
            var id = _t.id;
            // if (params.glbArray) {
            //     this.showSugt(val, params.glbArray);
            // } else {
            var data = {};
            var queryText_lowerCase = queryText.toLowerCase();
            var ptr = new RegExp('^' + [queryText_lowerCase] + '|\\s' + [queryText_lowerCase]);

            for (var x in sourceData[0]) {
                var filteredData = sourceData[0][x].filter(function (val, i) {
                    return val.displayTextEn.toLowerCase().match(ptr) ? true : false;
                });
                data[x] = filteredData;
            }
            this.showSugt({ val: queryText, data: data });
        };

        var trimSpace = function trimSpace(text) {
            return text.replace(/^\s*|\s*$/g, ''); // remove one or more space(s) from start and last
        };

        var getlastChar = function getlastChar(lastchar) {
            //'Unit Test Done':    this function gets last character after comma
            var txt = $.trim(lastchar).replace(/,*$/g, '').toLowerCase();
            return $.trim(txt.substring(txt.lastIndexOf(',') + 1, txt.length));
        };

        var extractTextAfterLastDelimiter = function extractTextAfterLastDelimiter(txt) {
            var delimiter = ",";
            // if (params.localSuggestions) {
            //     delimiter = " ";
            // } else {
            //     delimiter = ", ";
            // }
            txt = trimSpace(txt).toLowerCase();
            return trimSpace(txt.substring(txt.lastIndexOf(delimiter) + 1, txt.length));
        };

        var getAutoCompletes = function getAutoCompletes(val, trimVal) {
            var _t = this;
            if (params.localSuggestions) {
                val = trimVal;
            } else {
                if (params.multiSearch) val = _t.getlastChar(val);
            }
            if (val) {
                var URL = encodeURL.call(_t, params.url.autoComplete, val, false);
                makeAjax.call(_t, URL, function (resp) {
                    setResponse.call(_t, resp, val);
                });
            }
        };

        var showSugt = function showSugt(_ref2) {
            var val = _ref2.val,
                data = _ref2.data,
                relConcpt = _ref2.relConcpt,
                catagory = _ref2.catagory;

            var _t = this;
            /*
               issue : handle tab case : type "ja" and scroll to any position(e.g. third or fourth) 
               and again type "a"(final keyword : jav), now press tab key, val of last selected index
                fill in input box, which should not be.
                Fix : blank the _t.curElm reference
             */
            _t.curElm = undefined;
            var Li = Filter.call(_t, _t.getlastChar(val), data, relConcpt, catagory);
            if (Li) {
                _t.dropCont.find('ul').html(Li);
                show.call(_t);
            } else {
                hide.call(_t);
            }
        };

        return {
            getValue: getValue,
            get_RCdata: get_RCdata,
            sendTrackingData: sendTrackingData,
            getLocalSuggestions: getLocalSuggestions,
            returnDataArray: returnDataArray,
            extractTextAfterLastDelimiter: extractTextAfterLastDelimiter,
            getlastChar: getlastChar,
            getAutoCompletes: getAutoCompletes,
            showSugt: showSugt,
            trimSpace: trimSpace
        };
    }();

    var _this = $(params.trigger);
    var obj = _this.data('suggestor');

    if (!obj) {
        _this.each(function (index, node) {
            var _node = $(node);
            obj = new initialization(_node);
            _node.data('suggestor', obj);
            /**
             * For unit test cases
             * This section is only for development environment and should be removed from production
             * either from manual or through grunt
             */
            /*                if (DEBUG) {
                                obj.testObject = {
                                    txtAfterLastComma: txtAfterLastComma,
                                    decodeTxt: decodeTxt,
                                    checkLS: checkLS,
                                    makeAjax: makeAjax,
                                    setTrackingObject: setTrackingObject
                                }
                            }*/
            /*End of unit test cases*/
        });
    }
    return obj;
};

// return elm.val().match(/[\w\W\s@#]*(@|#)/g)[0] + txt; // get all the words or non words(special char) will match before last '@' or '#'

exports.suggestor = suggestor;

Object.defineProperty(exports, '__esModule', { value: true });

});